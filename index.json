[{"authors":["admin"],"categories":null,"content":"I am a PhD student in Computer Science at the University of California, Irvine in the Center for Algorithms and Theory of Computation. I am pleased to have Prof. Michael Goodrich as my advisor and to collaborate with Prof. David Eppstein.\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I am a PhD student in Computer Science at the University of California, Irvine in the Center for Algorithms and Theory of Computation. I am pleased to have Prof. Michael Goodrich as my advisor and to collaborate with Prof. David Eppstein.","tags":null,"title":"Pedro Ascensão Matias","type":"authors"},{"authors":["Ramtin Afshar","Michael T. Goodrich","Pedro Matias"],"categories":[],"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"a9600c9a8e095c599d07fb6f5f4437ad","permalink":"/publication/2020-reconstruction/","publishdate":"2019-09-22T23:01:18-07:00","relpermalink":"/publication/2020-reconstruction/","section":"publication","summary":"","tags":[],"title":"How to Steal a Tree: Efficient Reconstruction of Trees via Queries","type":"publication"},{"authors":["Alon Efrat","David Eppstein","Daniel Frishberg","Michael T. Goodrich","Stephen G. Kobourov","Nil Mamano","Pedro Matias","Valentin Polishchuk"],"categories":[],"content":"","date":1566542348,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1566542348,"objectID":"9fb79d224b20f3a1aaba7a22df275bc9","permalink":"/publication/2019-nnc/","publishdate":"2019-08-22T23:39:08-07:00","relpermalink":"/publication/2019-nnc/","section":"publication","summary":"We show new applications of the nearest-neighbor chain algorithm, a technique that originated in agglomerative hierarchical clustering. We apply it to a diverse class of geometric problems: we construct the greedy multi-fragment tour for Euclidean TSP in $O(n\\log n)$ time in any fixed dimension and for Steiner TSP in planar graphs in $O(n\\sqrt{n}\\log n)$ time; we compute motorcycle graphs (which are a central part in straight skeleton algorithms) in $O(n^{4/3+\\epsilon})$ time for any $\\epsilon0$; we introduce a narcissistic variant of the $k$-attribute stable matching model, and solve it in $O(n^{2-4/(k(1+\\epsilon)+2)})$ time; we give a linear-time $2$-approximation for a 1D geometric set cover problem with applications to radio station placement.","tags":[],"title":"Euclidean TSP, Motorcycle Graphs, and Other New Applications of Nearest-Neighbor Chains","type":"publication"},{"authors":["David Eppstein","Michael T. Goodrich","James A. Liu","Pedro Matias"],"categories":[],"content":"","date":1566540078,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1566540078,"objectID":"91e6ca403ec73ad457a07597b5beb519","permalink":"/publication/2019-tracking/","publishdate":"2019-08-22T23:01:18-07:00","relpermalink":"/publication/2019-tracking/","section":"publication","summary":"We consider the NP-complete problem of tracking paths in a graph, first introduced by Banik et. al. [3]. Given an undirected graph with a source $s$ and a destination $t$, find the smallest subset of vertices whose intersection with any $s−t$ path results in a unique sequence. In this paper, we show that this problem remains NP-complete when the graph is planar and we give a $4$-approximation algorithm in this setting. We also show, via Courcelle's theorem, that it can be solved in linear time for graphs of bounded-clique width, when its clique decomposition is given in advance.","tags":[],"title":"Tracking Paths in Planar Graphs","type":"publication"},{"authors":null,"categories":null,"content":" Designed and developed supervised Machine Learning models for predicting rainfall at a particular location. The project was carried out by 2 awesome teammates and myself, in hopes of getting a good grade on Prof. Sameer Singh\u0026rsquo;s course of Machine Learning.\nThe data Courtesy of the UC Irvine Center for Hydrometeorology and Remote Sensing, our data consisted of satellite-based measurements of temperature at particular locations across the globe (infrared imaging) and information about clouds (such as area and average temperature). Each data point corresponded to a location on the globe (identified by its latitude, longitude and elevation) and was labeled with CHRS\u0026rsquo;s belief of whether that particular location will admit rain.\nApproaches We tried the following models:\n Neural Networks and Deep Learning Random Forests Support Vector Machines  Random Forests turned out to be the model scoring highest in validation AUC, with scores above 0.79. We used hold-out validation with a training fraction of 80% of the data.\nExperiments were carried out using scikit-learn\u0026rsquo;s implementations of Random Forests (both RandomForestRegressor and ExtraTreesRegressor) and we experimented different configurations of the following parameters (see code at the end):\n max_depth. The maximum depth on all the decision trees. If None, the depth is unrestricted min_samples_split. The minimum number of samples to split a node (e.g. minParent) min_samples_leaf. The minimum number of samples to form a leaf max_features. The maximum size of the subsample of features considered in splitting n_estimators. The number of decision trees generated bootstrap. Either True or False. In scikit-learn, the subsample of the data (drawn with or without replacement) will always have the size as the data itself  Random Forest Results In the end, an unlimited max_depth together with small sizes of feature subsampling (max_features=2) and a large number of decision trees (n_estimators=300) turned out to be a very good configuration of params. The remaining parameters revealed little influence in validation AUC. See below for a plot of training and validation AUC\u0026rsquo;s varying max_features and n_estimators, with and without bootstrap.\n   RandomForestRegressor with bootstrap, min_samples_split=min_samples_leaf=5 and max_depth=None.      RandomForestRegressor without bootstrap, min_samples_split=min_samples_leaf=5 and max_depth=None.   The following plots are similar to the ones above, but using ExtraTreesRegressor instead, where in addition to using a random subset of splitting candidate features, it samples a random subsubset from this subset when evaluating the most discriminating splitting feature.\n   RandomForestRegressor with bootstrap, min_samples_split=min_samples_leaf=5 and max_depth=None.      RandomForestRegressor without bootstrap, min_samples_split=min_samples_leaf=5 and max_depth=None.   Random Forests code # Consistent behavior np.random.seed(0) def loadData(filename): \u0026quot;\u0026quot;\u0026quot; Load data from binary cache if possible for efficiency. \u0026quot;\u0026quot;\u0026quot; f = os.path.splitext(filename)[0] + '.npy' if os.path.isfile(f): D = np.load(f) # faster than genfromtxt else: D = np.genfromtxt(filename, delimiter = None) np.save(f, D) return D def gen_params(**params_ranges): params_ranges = {k: [(k, v) for v in params_ranges[k]] for k in params_ranges} return map(dict, itertools.product(*params_ranges.values())) if __name__ == '__main__': timestamp = str(int(time.time())) # Prepare output folder for results date = datetime.fromtimestamp(time.time()).strftime('%m-%d_%H-%M-%S') # Data Loading X = loadData('data/X_train.txt') Y = loadData('data/Y_train.txt') X, Y = ml.shuffleData(X,Y) m, n = X.shape Xtr, Xva, Ytr, Yva = ml.splitData(X, Y) Xt, Yt = Xtr, Ytr max_depth = [None] min_samples_split = [10] min_samples_leaf = [10] max_features = [2] n_estimators = [100] bootstrap = [True] type = ['RF'] params_ranges = {p: eval(p) for p in ['max_depth', 'min_samples_split', 'min_samples_leaf', 'max_features', 'n_estimators', 'bootstrap', 'type']} results = [] for params in gen_params(**params_ranges): t = params.pop('type') if t == 'RF': RF = RandomForestRegressor(n_jobs = -1, random_state = 0, **params) else: RF = ExtraTreesRegressor(n_jobs = -1, random_state = 0, **params) RF.fit(Xt, Yt) params['AUCt'] = roc_auc_score(Yt, RF.predict(Xt)) params['AUCv'] = roc_auc_score(Yva, RF.predict(Xva)) params['type'] = t results.append(params) if saveResults: with open('experiments/' + timestamp + '.json', 'w') as f: json.dump(results, f, indent = 2)  ","date":1512086400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1512086400,"objectID":"b0d87f153fa85f7d834f29319b1dad14","permalink":"/projects/rainfall-predictor/","publishdate":"2017-12-01T00:00:00Z","relpermalink":"/projects/rainfall-predictor/","section":"projects","summary":"ML for determining whether it is going to rain","tags":null,"title":"Rainfall Predictor","type":"projects"},{"authors":null,"categories":null,"content":"Language: C++11\nBuilt my own database management system from scratch, with the help of a teammate. This project was in the scope of the class \u0026ldquo;Principles of Data Management\u0026rdquo;, at UC Irvine, and was divided into the following parts:\n Disk I/O Page-Based Manager Record-Based File Manager Relation Manager Index Manager Query Engine  1. The Disk I/O Page-Based Manager\n Provides higher-layered managers with tools to perform I/O operations in terms of pages (eg: open/close file, create/destroy file and read/write pages to the file).  2. Record-Based File Manager\n Responsible for inserting, deleting and updating records within a given page-based file. Records are identified and located within a file by a pair (pageNumber, recordSlot) called RID. The attribute types supported are: INT, REAL and VARHCAR(N). Thus, variable-length records are possible. It has the responsibility of managing the free space offset within a page and guarantee $O(1)$ time for accessing the $i^{th}$ attribute of the record. For this reason, both pages and records are encoded in disk with a specific format chosen by the manager itself.  3. Relation Manager\n Responsible for managing the database tables (creating/deleting tables and inserting/removing tuples) It keeps database schema in the system catalog, which is itself a table  4. Index Manager\n Implemented using a B+ Tree that supports all the necessary operations: insertion, removal, key lookup and range scan. Every node in the tree, intermediate or leaf node, corresponds to a page of size 4096 bytes and it must be at least half full \u0026ndash; requirement for B+ trees to reduce sparsity and fragmentation. For simplicity, we don\u0026rsquo;t care about keeping the above property whenever deleting a record. This is because merging nodes is a complex task (splitting in insert are simpler) and deletes are not frequent.  5. Query Engine\n Provides the functionality to answer SQL queries The following relational operators were implemented:  Filter Projection Aggregate (with \u0026ldquo;Group by\u0026rdquo;) Join, using: Block-Nested Loop Join Index-Nested Loop Join   ","date":1480550400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1480550400,"objectID":"a252fc5f905ff02a437ab0edcf6f398c","permalink":"/projects/dbms/","publishdate":"2016-12-01T00:00:00Z","relpermalink":"/projects/dbms/","section":"projects","summary":"Database from scratch","tags":null,"title":"dbms","type":"projects"},{"authors":["Luís Paquete","Pedro Matias","Maryam Abbasi","Miguel Pinheiro"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"3ab4673aa097f51c41b82d7a3d64e147","permalink":"/publication/2013-mosal2/","publishdate":"2019-08-26T00:00:34.875727Z","relpermalink":"/publication/2013-mosal2/","section":"publication","summary":": Multiobjective sequence alignment brings the advantage of providing a set of alignments that represent the trade-off between performing insertion/deletions and matching symbols from both sequences. Each of these alignments provide a potential explanation of the relationship between the sequences. We introduce MOSAL, a software tool that provides an open-source implementation and an on-line application for multiobjective pairwise sequence alignment.","tags":["Dynamic programming","Multiobjective optimization","Pairwise sequence alignment"],"title":"MOSAL: Software tools for multiobjective sequence alignment","type":"publication"},{"authors":null,"categories":null,"content":"An XMPP Instant Messaging client pontarius-xmpp using vty-ui as user interface. Includes support for Jabber.\nLanguage: Haskell\nInstallation\n$ cabal sandbox init\n$ cabal install\n Mac OSX: In order to install text-icu, you need the C libraries: icuuc, icui18n, icudata  $ brew install icu4c $ cabal install text-icu --extra-include-dirs=/usr/local/Cellar/icu4c/53.1/include/ --extra-lib-dirs=/usr/local/Cellar/icu4c/53.1/lib    Or the equivalent using MacPorts.\nUsage\n$ cabal configure\n$ cabal run\n","date":1385856000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1385856000,"objectID":"7910f2a13d34d007e54d998acb343fbe","permalink":"/projects/pemo/","publishdate":"2013-12-01T00:00:00Z","relpermalink":"/projects/pemo/","section":"projects","summary":"An XMPP Instant Messaging client written in Haskell","tags":null,"title":"PeMo","type":"projects"},{"authors":null,"categories":null,"content":" Design and implementation of a compiler from scratch, including:\n Lexical analysis Syntactic analysis  Abstract syntax tree (AST) construction  Semantic analysis Code generation  It\u0026rsquo;s written in C and it compiles input files written in qC, a small subset of the language ANSI C (C89/C90). The generated code is in C, but very close to Assembly.\nFeatures of qC  use variables and literals of types character and integer (both with signal) function declarations/calls, with recursion support pointers to variables and literals and to other pointers unidimensional arrays for integers, characters or pointers literals of type string arithmetic and logic expressions (check language grammar) simple relational operations pointer operations assign operations control operations (if-else and while) output operations (simplified version of printf) conversion between integers and strings - operations itoa and atoi comments of type /* \u0026hellip; */  Tokens    Token Meaning     ID alphameric case sensitive sequences beginning with a letter where \u0026lsquo;_\u0026rsquo; is also allowed   INTLIT sequence of digits without unnecessary left pad zeros   CHRLIT single character (except newline or single quote) or escape sequence (\\n, \\t, \\, \\\u0026lsquo;, \\\u0026rdquo; and \\0) between single quotes   STRLIT sequence of characters (except newline or single quote) and/or escape sequences between double quotes   AMP \u0026amp;   AND \u0026amp;\u0026amp;   ASSIGN =   AST *   ATOI atoi   CHAR char   COMMA ,   DIV /   ELSE else   EQ ==   GE \u0026gt;=   GT \u0026gt;   IF if   INT int   ITOA itoa   LBRACE {   LE \u0026lt;=   LPAR (   LSQ [   LT \u0026lt;   MINUS -   MOD %   NE !=   NOT !   OR `   PLUS +   PRINTF printf   RBRACE }   RETURN return   RPAR )   RSQ ]   SEMI ;   WHILE while   RESERVED C keywords not used in qC    Grammar (EBNF notation) Start → (FunctionDefinition | FunctionDeclaration | Declaration) {FunctionDefinition | FunctionDeclaration | Declaration}\nFunctionDefinition → TypeSpecifier FunctionDeclarator LBRACE {Declaration} {Statement} RBRACE\nFunctionDeclaration → TypeSpecifier FunctionDeclarator SEMI\nFunctionDeclarator → {AST} ID LPAR [ParameterList] RPAR\nParameterList → ParameterDeclaration {COMMA ParameterDeclaration}\nParameterDeclaration → TypeSpecifier {AST} ID\nDeclaration → TypeSpecifier Declarator {COMMA Declarator} SEMI\nTypeSpecifier → CHAR | INT\nDeclarator → {AST} ID [LSQ INTLIT RSQ]\nStatement → [Expression] SEMI\nStatement → LBRACE {Statement} RBRACE\nStatement → IF LPAR Expression RPAR Statement [ELSE Statement]\nStatement → WHILE LPAR Expression RPAR Statement\nStatement → RETURN Expression SEMI\nExpression → Expression ASSIGN Expression\nExpression → Expression (AND | OR) Expression\nExpression → Expression (EQ | NE | LT | GT | LE | GE) Expression\nExpression → Expression (PLUS | MINUS | AST | DIV | MOD) Expression\nExpression → (AMP | AST | PLUS | MINUS | NOT) Expression\nExpression → Expression LSQ Expression RSQ\nExpression → ID LPAR [Expression {COMMA Expression}] RPAR\nExpression → (PRINTF | ATOI) LPAR Expression RPAR\nExpression → ITOA LPAR Expression COMMA Expression RPAR\nExpression → ID | INTLIT | CHRLIT | STRLIT | LPAR Expression RPAR\nUsage $ make $ ./qccompiler [OPTIONS] \u0026lt; input.qc  Options: -t \u0026nbsp; \u0026nbsp; print the abstract syntax tree and stop after syntatic analysis.\n-s \u0026nbsp; \u0026nbsp; print the symbol table and stop after semantic analisys.\n-c \u0026nbsp; \u0026nbsp; allways compile the program (unless errors occur).\n-o \u0026nbsp; \u0026nbsp; allways compile the program (unless errors occur) and print compiled program to file.\nIf both flags -s and -t are set, the proccess stops after the semantic analysis. The result of the compilation is written to the file `result.c\nDependencies  flex yacc gcc  ","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"301d8e874b970c7398d76bfb4e4fc39c","permalink":"/projects/qccompiler/","publishdate":"2013-07-01T00:00:00Z","relpermalink":"/projects/qccompiler/","section":"projects","summary":"A quasi-C compiler from scratch","tags":null,"title":"qccompiler","type":"projects"},{"authors":null,"categories":null,"content":" Implementation from scratch of Tic-Tac-Toe in a 3D environment.\nFrameworks: OpenGL\nLanguage: C++\nKeys X: switch player\nW: ↑\nA: ←\nS: ↓\nD: ➝\nEsc: quit the game\nFor playing in the board:\n   T Y U     G H J   B N M    Installation $ git clone git@github.com:zydeon/tictactoe.git $ cd tictactoe $ make  ","date":1370044800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1370044800,"objectID":"1848da46e4abdbdb8f067ee60cec7213","permalink":"/projects/tic-tac-toe/","publishdate":"2013-06-01T00:00:00Z","relpermalink":"/projects/tic-tac-toe/","section":"projects","summary":"Tic-Tac-Toe in a 3D environment.","tags":null,"title":"GL-TicTacToe","type":"projects"},{"authors":["Maryam Abbasi","Luís Paquete","Arnaud Liefooghe","Miguel Pinheiro","Pedro Matias"],"categories":null,"content":"","date":1356998400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1356998400,"objectID":"204563bcc19b3ec6f5b4739b405bd200","permalink":"/publication/2013-mosal1/","publishdate":"2019-08-26T00:00:34.877591Z","relpermalink":"/publication/2013-mosal1/","section":"publication","summary":"Motivation: In this article, we consider the bicriteria pairwise sequence alignment problem and propose extensions of dynamic programming algorithms for several problem variants with a novel pruning technique that efficiently reduces the number of states to be processed. Moreover, we present a method for the construction of phylogenetic trees based on this bicriteria framework. Two exemplary cases are discussed. Results: Numerical results on a real dataset show that this approach is very fast in practice. The pruning technique saves up to 90% in memory usage and 80% in CPU time. Based on this method, phylogenetic trees are constructed from real-life data. In addition of providing complementary information, some of these trees match those obtained by the Maximum Likelihood method. Availability and implementation: Source code is freely available for download at URL http://eden.dei.uc.pt/paquete/MOSAL, implemented in C and supported on Linux, MAC OS and MS Windows.","tags":null,"title":"Improvements on bicriteria pairwise sequence alignment: Algorithms and applications","type":"publication"},{"authors":null,"categories":null,"content":" A social network application with integration with Facebook REST API and updates in real-time for users social activity, by making use of WebSockets.\nFeatures  Register user Login user Create a new post (with or without Images) Edit a previous post Delete a previous post Reply to any post Send Direct Messages to other users See online users (automatically updated) Join chatrooms When a post is created, it\u0026rsquo;s created on Facebook. When a post is deleted, it\u0026rsquo;s deleted on Facebook. When a reply is made, it\u0026rsquo;s added on Facebook.  Overall architecture The application uses 2 servers and 3 types of client: TCP, RMI (Remote Method Invocation, and HTTP. See the diagram above.\nPre-requisites  JDBC driver Apache Tomcat WebBrowser with support to websockets  ","date":1354320000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1354320000,"objectID":"2587055954b4ecba6d9d4216a899004a","permalink":"/projects/socnet/","publishdate":"2012-12-01T00:00:00Z","relpermalink":"/projects/socnet/","section":"projects","summary":"A social network application","tags":null,"title":"SocNet","type":"projects"},{"authors":null,"categories":null,"content":"","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"021619127fc6d2ae48d7bb0344bef8cc","permalink":"/industry/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/industry/","section":"","summary":"","tags":null,"title":"","type":"widget_page"}]